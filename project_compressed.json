{
    "swagger.yaml": "openapi: 3.0.0\ninfo:\n  title: Node.js DynamoDB Server API\n  version: 1.0.0\ntags:\n  - name: auth\n    description: Authentication related operations (login, register, etc.)\n  - name: user\n    description: User related operations (update, delete, etc.)\n  - name: otp\n    description: OTP related operations (send, verify, etc.)\npaths:\n  # Auth routes\n  /api/auth/register:\n    post:\n      tags:\n        - auth\n      summary: Register a new user\n      description: Allows users to register by providing personal information, academic details, and uploading documents.\n      operationId: registerUser\n      requestBody:\n        required: true\n        content:\n          multipart/form-data:\n            schema:\n              type: object\n              properties:\n                name:\n                  type: string\n                  example: John Doe\n                  description: Full name of the user.\n                email:\n                  type: string\n                  format: email\n                  example: user@example.com\n                  description: Email address of the user.\n                password:\n                  type: string\n                  example: yourPassword123\n                  description: The password chosen by the user.\n                gender:\n                  type: string\n                  enum: [Male, Female, Other]\n                  example: Male\n                  description: The gender of the user.\n                phoneNumber:\n                  type: string\n                  example: \"+1234567890\"\n                  description: The user's phone number.\n                dob:\n                  type: string\n                  format: date\n                  example: \"2000-01-01\"\n                  description: The user's date of birth.\n                is_email_verified:\n                  type: boolean\n                  example: false\n                  description: Whether the user's email is verified.\n                address:\n                  type: string\n                  example: 123 Main St, ABC City\n                  description: Residential address of the user.\n                pincode:\n                  type: string\n                  example: 123456\n                  description: Postal code of the user's address.\n                state:\n                  type: string\n                  example: State A\n                  description: The state the user resides in.\n                marks10:\n                  type: integer\n                  example: 85\n                  description: Marks obtained in 10th grade.\n                marks12:\n                  type: integer\n                  example: 90\n                  description: Marks obtained in 12th grade.\n                higherDegreeScore:\n                  type: integer\n                  example: 88\n                  description: Marks/score obtained in higher degree (e.g., Bachelor's degree).\n                previousYearScore:\n                  type: integer\n                  example: 92\n                  description: Marks obtained in the previous year.\n                examRegisteredFor:\n                  type: string\n                  example: GATE CS\n                  description: The exam the user is registered for (e.g., GATE CS).\n                profilePicture:\n                  type: string\n                  format: binary\n                  description: The user's profile picture in JPEG or PNG format.\n                pdf10th:\n                  type: string\n                  format: binary\n                  description: PDF document of the user's 10th grade certificate.\n                pdf12th:\n                  type: string\n                  format: binary\n                  description: PDF document of the user's 12th grade certificate.\n                pdfHigherDegrees:\n                  type: array\n                  items:\n                    type: string\n                    format: binary\n                  description: One or more PDF documents of the user's higher degree certificates.\n                pdfPreviousYear:\n                  type: string\n                  format: binary\n                  description: PDF document of the user's previous year certificate.\n      responses:\n        '200':\n          description: User registered successfully\n        '400':\n          description: Bad request, missing or invalid data\n        '500':\n          description: Internal server error\n\n  /api/auth/login:\n    post:\n      tags:\n        - auth\n      summary: Login a user\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                email:\n                  type: string\n                password:\n                  type: string\n      responses:\n        '200':\n          description: Logged in successfully\n        '400':\n          description: Invalid credentials\n        '500':\n          description: Internal server error\n\n  /api/auth/logout:\n    post:\n      tags:\n        - auth\n      summary: Logout a user\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: Logged out successfully\n        '401':\n          description: Unauthorized\n        '500':\n          description: Internal server error\n\n  /api/auth/forgot-password:\n    post:\n      tags:\n        - auth\n      summary: Request password reset\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                email:\n                  type: string\n      responses:\n        '200':\n          description: Password reset email sent\n        '400':\n          description: Missing email or invalid input\n        '500':\n          description: Internal server error\n\n  /api/auth/reset-password:\n    post:\n      tags:\n        - auth\n      summary: Reset password\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                resetToken:\n                  type: string\n                newPassword:\n                  type: string\n      responses:\n        '200':\n          description: Password reset successfully\n        '400':\n          description: Missing reset token or new password\n        '500':\n          description: Internal server error\n\n  # OTP routes\n  /api/otp/send:\n    post:\n      tags:\n        - otp\n      summary: Send OTP to the user's email for verification\n      description: This endpoint sends an OTP to the provided email address for email verification.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                email:\n                  type: string\n                  format: email\n                  example: \"user@example.com\"\n              required:\n                - email\n      responses:\n        '200':\n          description: OTP sent successfully\n        '400':\n          description: Missing email or invalid input\n        '500':\n          description: Internal server error\n\n  /api/otp/verify:\n    post:\n      tags:\n        - otp\n      summary: Verify the OTP entered by the user\n      description: This endpoint verifies the OTP entered by the user for email verification.\n      requestBody:\n        required: true\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                email:\n                  type: string\n                  format: email\n                  example: \"user@example.com\"\n                otp:\n                  type: string\n                  example: \"123456\"\n              required:\n                - email\n                - otp\n      responses:\n        '200':\n          description: Email verified successfully\n        '400':\n          description: Invalid OTP or OTP expired\n        '500':\n          description: Internal server error\n\n  # User routes\n  /api/user/update:\n    put:\n      tags:\n        - user\n      summary: Update user details\n      security:\n        - bearerAuth: []\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                name:\n                  type: string\n                email:\n                  type: string\n      responses:\n        '200':\n          description: User updated successfully\n        '400':\n          description: Bad request, missing or invalid data\n        '500':\n          description: Internal server error\n\n  /api/user/delete:\n    delete:\n      tags:\n        - user\n      summary: Delete user account\n      security:\n        - bearerAuth: []\n      responses:\n        '200':\n          description: User deleted successfully\n        '401':\n          description: Unauthorized\n        '500':\n          description: Internal server error\n\n  /api/user/{email}:\n    get:\n      tags:\n        - user\n      summary: Get user details\n      description: Fetches the user details from the LMS-AUTH, LMS-USER-DATA, and LMS-USER-DOCS tables based on the provided email.\n      parameters:\n        - name: email\n          in: path\n          required: true\n          description: The email of the user to fetch data for.\n          schema:\n            type: string\n            example: \"test@example.com\"\n      responses:\n        '200':\n          description: Successful response with user data.\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  email:\n                    type: string\n                    example: \"test@example.com\"\n                  authData:\n                    type: object\n                    example: { \"email\": \"test@example.com\" }\n                  userData:\n                    type: object\n                    example: { \"email\": \"test@example.com\" }\n                  userDocs:\n                    type: object\n                    example: { \"email\": \"test@example.com\" }\n        '400':\n          description: Invalid email format or missing email.\n        '404':\n          description: User not found in any of the tables.\n        '500':\n          description: Internal server error or error fetching user data.\n\ncomponents:\n  securitySchemes:\n    bearerAuth:\n      type: http\n      scheme: bearer\n      bearerFormat: JWT",
    "app.js": "import express from 'express';\nimport cookieParser from 'cookie-parser';\nimport swaggerUi from 'swagger-ui-express';\nimport YAML from 'yamljs';\nimport authRoutes from './routes/AuthRoutes.js';\nimport userRoutes from './routes/UserRoutes.js';\nimport otpRoutes from './routes/OtpRoutes.js'\nimport { errorHandler } from './middleware/ErrorMiddleware.js';\nimport cors from 'cors';\nimport dotenv from 'dotenv';\nimport AuthMiddleware from './middleware/AuthMiddleware.js';\nimport batchRoutes from \"./routes/BatchRoutes.js\"\n\n\nconst app = express();\nconst swaggerDocument = YAML.load('./swagger.yaml');\n\napp.use(cors({\n    origin: [\"http://127.0.0.1:5173\", \"http://localhost:5173\"], \n    methods: \"GET,POST,PUT,DELETE\",\n    allowedHeaders: \"Content-Type,Authorization\",\n    credentials: true\n}));\n\napp.options(\"*\", cors());\n\n\napp.use(express.json());\napp.use(cookieParser());\n\napp.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerDocument));\n\napp.use('/api/auth', authRoutes);\napp.use('/api/user', AuthMiddleware.auth, userRoutes);\napp.use('/api/otp/', otpRoutes)\napp.use('/api/batch/', batchRoutes)\n\napp.use(errorHandler);\n\napp.listen(5000, () => console.log('Server running on port 5000'));\n",
    "config/dynamoDB.js": "import { DynamoDBClient } from '@aws-sdk/client-dynamodb';\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nconst ddbClient = new DynamoDBClient({\n  region: process.env.AWS_REGION,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n});\n\nexport default ddbClient;\n",
    "config/s3.js": "const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3');\nconst dotenv = require('dotenv');\n\ndotenv.config();\n\nconst s3 = new S3Client({\n  region: process.env.AWS_REGION,\n  credentials: {\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n});\n\nconst uploadFile = async (file) => {\n  const params = {\n    Bucket: process.env.S3_BUCKET_NAME,\n    Key: `${Date.now()}_${file.originalname}`,\n    Body: file.buffer,\n    ContentType: file.mimetype,\n  };\n\n  try {\n    const command = new PutObjectCommand(params);\n    const data = await s3.send(command);\n    return { success: true , Location:`https://${process.env.S3_BUCKET_NAME}.s3.amazonaws.com/${params.Key}`};\n  } catch (err) {\n    console.error('Error uploading file to S3:', err);\n    return { success: false, message: 'Error uploading file' };\n  }\n};\n\nmodule.exports = { uploadFile };\n",
    "utils/idGenerator.js": "import { v4 as uuidv4 } from 'uuid';\n\nexport const generateUniqueId = () => {\n    return uuidv4();\n};",
    "services/BatchService.js": "import BatchModel from '../models/BatchModel.js';\nimport { generateUniqueId } from '../utils/idGenerator.js';\n\nclass BatchService {\n    async createBatch(teacher_email, batch_name, description) {\n        const batch_id = generateUniqueId();\n        const batch = { batch_id, teacher_email, batch_name, description };\n        return BatchModel.createBatch(batch);\n    }\n\n    async getBatch(batch_id) {\n        return BatchModel.getBatchById(batch_id);\n    }\n\n    async getAllBatches() {\n        return BatchModel.getAllBatches();\n    }\n\n    async updateBatch(batch_id, updatedBatchData) {\n        return BatchModel.updateBatch(batch_id, updatedBatchData);\n    }\n\n    async deleteBatch(batch_id) {\n        return BatchModel.deleteBatch(batch_id);\n    }\n}\n\nconst batchService = new BatchService();\nexport default batchService;",
    "services/ClassService.js": "import classData from '../data/classData.js';\nimport { generateId } from '../utils/idGenerator.js';\n\nclass ClassService {\n    static async createClass(teacher_id, course_id, class_title, class_date_time, recording_url) {\n        const class_id = generateId();\n        const cls = { class_id, teacher_id, course_id, class_title, class_date_time, recording_url }; // Use \"cls\" here\n        return classData.createClass(cls);\n    }\n\n    static async getClass(class_id) {\n        return classData.getClassById(class_id);\n    }\n\n    static async getClassesByCourseId(course_id) {\n        return classData.getClassesByCourseId(course_id);\n    }\n\n    static async updateClass(class_id, updatedClassData) {\n        return classData.updateClass(class_id, updatedClassData);\n    }\n\n    static async deleteClass(class_id) {\n        return classData.deleteClass(class_id);\n    }\n}\n\nexport default ClassService;",
    "services/CourseService.js": "import courseData from '../data/courseData.js';\nimport { generateId } from '../utils/idGenerator.js';\n\nclass CourseService {\n    static async createCourse(teacher_id, batch_id, course_name, allow_notes_download) {\n        const course_id = generateId();\n        const course = { course_id, teacher_id, batch_id, course_name, allow_notes_download };\n        return courseData.createCourse(course);\n    }\n\n    static async getCourse(course_id) {\n        return courseData.getCourseById(course_id);\n    }\n\n    static async getCoursesByBatchId(batch_id) {\n        return courseData.getCoursesByBatchId(batch_id);\n    }\n\n    static async updateCourse(course_id, updatedCourseData) {\n        return courseData.updateCourse(course_id, updatedCourseData);\n    }\n\n    static async deleteCourse(course_id) {\n        return courseData.deleteCourse(course_id);\n    }\n}\n\nexport default CourseService;",
    "services/EmailService.js": "import nodemailer from \"nodemailer\";\n\nconst transporter = nodemailer.createTransport({\n  service: \"gmail\",\n  auth: {\n    user: process.env.EMAIL_USER,\n    pass: process.env.EMAIL_PASS,\n  },\n});\n\nclass EmailService {\n  static async sendEmailService(email, type, linkOrOtp) {\n    let subject, htmlContent;\n  \n    if (type === \"passwordReset\") {\n      subject = \"Password Reset Request\";\n      htmlContent = `\n        <h3>Password Reset Request</h3>\n        <p>You requested a password reset. Please click the link below to reset your password:</p>\n        <a href=\"${linkOrOtp}\">Reset Password</a>\n        <p>If you did not request this, please ignore this email.</p>\n      `;\n    } else if (type === \"emailVerification\") {\n      subject = \"Email Verification OTP\";\n      htmlContent = `\n        <h3>Email Verification</h3>\n        <p>Your OTP for email verification is: <strong>${linkOrOtp}</strong></p>\n        <p>If you did not request this, please ignore this email.</p>\n      `;\n    } else if (type === \"emailLogin\") {\n      subject = \"Email Login OTP\";\n      htmlContent = `\n        <h3>Email Login</h3>\n        <p>Your OTP Login to ${process.env.APP_NAME}: <strong>${linkOrOtp}</strong></p>\n        <p>If you did not request this, please ignore this email.</p>\n      `;\n    } else {\n      throw new Error(\"Invalid email type\");\n    }\n  \n    const mailOptions = {\n      from: process.env.EMAIL_USER,\n      to: email,\n      subject,\n      html: htmlContent,\n    };\n  \n    try {\n      await transporter.sendMail(mailOptions);\n      return { success: true, statusCode: 200, message: \"Email sent successfully\" };\n    } catch (error) {\n      console.error(\"Error sending email:\", error);\n      return { success: false, statusCode: 500, message: \"Error sending email\" };\n    }\n  }  \n}\n\nexport default EmailService;\n",
    "services/UserService.js": "import UserModel from \"../models/UserModel.js\";\n\nclass UserService {\n  static async updateUserService(userId, updateData) {\n    try {\n      const updatedUser = await UserModel.updateUser(userId, updateData);\n      if (updatedUser.success) {\n        return { success: true, statusCode: 200, message: \"User updated successfully\", data: updatedUser.data };\n      } else {\n        return { success: false, statusCode: 400, message: \"Error updating user\" };\n      }\n    } catch (error) {\n      return { success: false, statusCode: 500, message: error.message || \"An error occurred while updating user\" };\n    }\n  }\n  \n  static async deleteUserService(userId) {\n    try {\n      await UserModel.deleteUser(userId);\n      return { success: true, statusCode: 200, message: \"User deleted successfully\" };\n    } catch (error) {\n      return { success: false, statusCode: 500, message: error.message || \"An error occurred while deleting the user\" };\n    }\n  }\n  \n\n  static async getUserDataByEmail(email) {\n    try {\n      const user = await UserModel.getUserDataByEmail(email);\n  \n      if (!user) {\n        return { success: false, statusCode: 404, message: \"User not found\" };\n      }\n  \n      const authData = user.authData;\n      const userData = user.userData;\n      const userDocs = user.userDocs;\n  \n      return { success: true, statusCode: 200, message: \"User data retrieved successfully\", email, authData, userData, userDocs };\n    } catch (error) {\n      console.error(\"Error fetching user data in service:\", error);\n      return { success: false, statusCode: 500, message: \"Error fetching user data\" };\n    }\n  }\n  \n}\n\nexport default UserService;\n",
    "services/OtpService.js": "let otpStore = {};\n\nclass OtpService {\n  static generateOtp() {\n  return Math.floor(100000 + Math.random() * 900000).toString();\n}\n\nstatic saveOtp(email, otp, otpExpiry) {\n  otpStore[email] = { storedOtp: otp, otpExpiry };\n}\n\nstatic getOtp(email) {\n  const otp = otpStore[email];\n  if (otp) {\n    return { success: true, statusCode: 200, message: \"OTP retrieved\", otp };\n  } else {\n    return { success: false, statusCode: 404, message: \"OTP not found\" };\n  }\n}\n\nstatic deleteOtp(email) {\n  const otpExists = otpStore[email];\n  if (otpExists) {\n    delete otpStore[email];\n    return { success: true, statusCode: 200, message: \"OTP deleted\" };\n  }\n  return { success: false, statusCode: 404, message: \"OTP not found\" };\n}\n\n}\n\nexport default OtpService;\n",
    "services/AuthService.js": "import bcrypt from \"bcryptjs\";\nimport jwt from \"jsonwebtoken\";\nimport UserModel from \"../models/UserModel.js\";\nimport UserSession from \"../models/UserSession.js\";\nimport { uploadFile } from \"../config/s3.js\";\nimport EmailService from \"./EmailService.js\";\nimport OtpService from \"./OtpService.js\";\n\nclass AuthService {\n  static async registerUserService(userData) {\n    const {\n      name,\n      email,\n      phoneNumber,\n      exam_registered_for\n    } = userData;\n  \n    try {\n      const existingUser = await UserModel.getUserByEmail(email);\n      if (existingUser.success) {\n        return { success: false, statusCode: 400, message: \"User already exists\" };\n      }\n  \n      await UserModel.createUser({\n        name,\n        email,\n        phoneNumber,\n        role:\"student\",\n        exam_registered_for\n      });\n  \n      return { success: true, statusCode: 201, message: \"User registered successfully\" };\n    } catch (error) {\n      return { success: false, statusCode: 500, message: error.message || \"An error occurred while registering the user\" };\n    }\n  }\n\n  static async registerUserWithRole(user){\n    try{\n      const existingUser = await UserModel.getUserByEmail(user.email);\n      if(existingUser.success){\n        return {success: false, statusCode:400, message: \"User already registered.\"}\n      }\n      await UserModel.createUser(user);\n      return { success: true, statusCode: 201, message: \"User registered successfully\" };\n    } catch (error) {\n      return { success: false, statusCode: 500, message: error.message || \"An error occurred while registering the user\" };\n    }\n  }\n\n  static async loginUserService(email, deviceType, password) {\n    try {\n      const response = await UserModel.getUserByEmail(email);\n      if (!response.success) {\n        return { success: false, statusCode: 400, message: response.message || response.error };\n      }\n  \n      const user = response.data;\n      const isMatch = await bcrypt.compare(password, user.password);\n      if (!isMatch) {\n        return { success: false, statusCode: 401, message: \"Invalid credentials\" };\n      }\n  \n      const session = await this.createSessionService(email, deviceType);\n      return { success: true, statusCode: 200, message: \"Login successful\", token: session.token };\n    } catch (error) {\n      return { success: false, statusCode: 500, message: error.message || \"An error occurred during login\" };\n    }\n  }\n\n  static async generateEmailOtpService(phoneNumber) {\n    try {\n      const user = await UserModel.getUserPhoneNumber(phoneNumber)\n      if (!user.success) {\n        return { success: false, statusCode: 404, message: \"User not found\" };\n      }\n      const email = user.email;\n  \n      const otp = OtpService.generateOtp();\n      const otpExpiry = Date.now() + 5 * 60 * 1000;\n  \n      OtpService.saveOtp(email, otp, otpExpiry);\n  \n      await EmailService.sendEmailService(email, \"emailLogin\", otp);\n  \n      return { success: true, statusCode: 200, message: \"OTP sent to your email\", email: email };\n    } catch (error) {\n      console.error(\"Error generating OTP for email:\", error);\n      return { success: false, statusCode: 500, message: \"Something went wrong while generating OTP\" };\n    }\n  }\n\n  static async loginWitEmailService(email, deviceType, otp) {\n    try {\n      const response = OtpService.getOtp(email);\n      if (!response.success) {\n        return { success: false, statusCode: 400, message: \"OTP not found or expired\" };\n      }\n      const otpData = response.otp;\n      if (otpData.otpExpiry < Date.now()) {\n        OtpService.deleteOtp(email);\n        return { success: false, statusCode: 400, message: \"OTP has expired\" };\n      }\n      if (otpData.storedOtp !== otp) {\n        return { success: false, statusCode: 400, message: \"Invalid OTP\" };\n      }\n  \n      OtpService.deleteOtp(email);\n  \n      const sessionResult = await this.createSessionService(email, deviceType);\n  \n      if (sessionResult.statusCode === 200) {\n        return { success: true, statusCode: 200, message: \"Login successful\", authToken: sessionResult.token };\n      }\n  \n      return { success: false, statusCode: sessionResult.status, message: sessionResult.message };\n    } catch (error) {\n      console.error(\"Error during OTP validation:\", error);\n      return { success: false, statusCode: 500, message: \"Something went wrong\" };\n    }\n  }\n\n  static async createSessionService(email, deviceType) {\n    try {\n      const token = jwt.sign({ email, deviceType }, process.env.JWT_SECRET, {\n        expiresIn: process.env.JWT_EXPIRES_IN,\n      });\n  \n      await UserSession.createOrUpdateSession(email, deviceType, token);\n      return { success: true, statusCode: 200, message: \"Session created successfully\", token: token };\n    } catch (error) {\n      console.error(\"Error during session creation:\", error);\n      return { success: false, statusCode: 500, message: \"Something went wrong while creating session\" };\n    }\n  }\n\n  static async resetPasswordService(resetToken, newPassword) {\n    try {\n      const decoded = jwt.verify(resetToken, process.env.JWT_SECRET);\n      const email = decoded.email;\n      const hashedPassword = await bcrypt.hash(newPassword, 10);\n  \n      const result = await UserModel.updatePassword(email, hashedPassword);\n  \n      if (result.success) {\n        return { success: true, statusCode: 200, message: \"Password reset successfully\" };\n      } else {\n        return { success: false, statusCode: 400, message: \"Error resetting password\" };\n      }\n    } catch (err) {\n      console.error(\"Error resetting password:\", err);\n      return { success: false, statusCode: 500, message: \"Error resetting password\" };\n    }\n  }\n\n  static async getResetTokenService(email) {\n    try {\n      const response = await UserModel.getUserByEmail(email);\n      if (!response.success) {\n        return { success: false, statusCode: 400, message: response.message || response.error };\n      }\n  \n      const user = response.data;\n  \n      const resetToken = jwt.sign({ email: user.email }, process.env.JWT_SECRET, {\n        expiresIn: \"10m\",\n      });\n  \n      return { success: true, statusCode: 200, message: \"Reset token generated\", resetToken };\n    } catch (error) {\n      console.error(\"Error generating reset token:\", error);\n      return { success: false, statusCode: 500, message: \"Error generating reset token\" };\n    }\n  }\n\n}\n\nexport default AuthService;\n",
    "controllers/CourseController.js": "import CourseService from '../services/courseService.js';\n\nclass CourseController {\n    static async createCourse(req, res) {\n        try {\n            const { batch_id, course_name, allow_notes_download } = req.body;\n            const teacher_id = req.user.user_id;\n\n            const newCourse = await CourseService.createCourse(teacher_id, batch_id, course_name, allow_notes_download);\n            res.status(201).json(newCourse);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to create course' });\n        }\n    }\n\n    static async getCourse(req, res) {\n        try {\n            const course = await CourseService.getCourse(req.params.course_id);\n            if (!course) {\n                return res.status(404).json({ error: 'Course not found' });\n            }\n            res.json(course);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get course' });\n        }\n    }\n\n    static async getCoursesByBatchId(req, res) {\n        try {\n            const courses = await CourseService.getCoursesByBatchId(req.params.batch_id);\n            res.json(courses);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get courses' });\n        }\n    }\n\n    static async updateCourse(req, res) {\n        try {\n            const updatedCourse = await CourseService.updateCourse(req.params.course_id, req.body);\n            res.json(updatedCourse);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to update course' });\n        }\n    }\n\n    static async deleteCourse(req, res) {\n        try {\n            await CourseService.deleteCourse(req.params.course_id);\n            res.status(204).end();\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to delete course' });\n        }\n    }\n}\n\nexport default CourseController;",
    "controllers/EmailController.js": "import EmailService from \"../services/EmailService.js\";\nimport OtpService from \"../services/OtpService.js\";\n\nclass EmailController {\n  static async sendEmailOtp(req, res) {\n    const { email } = req.body;\n  \n    if (!email) {\n      return res.status(400).json({ error: \"Email is required\" });\n    }\n  \n    try {\n      const otp = OtpService.generateOtp();\n      const otpExpiry = Date.now() + 15 * 60 * 1000;\n  \n      OtpService.saveOtp(email, otp, otpExpiry);\n  \n      const emailResponse = await EmailService.sendEmailService(email, \"emailVerification\", otp);\n  \n      if (emailResponse.success) {\n        return res.status(emailResponse.statusCode).json({ message: emailResponse.message });\n      } else {\n        return res.status(500).json({ error: \"Failed to send OTP\" });\n      }\n    } catch (error) {\n      console.error(\"Error sending email OTP:\", error);\n      return res.status(500).json({ error: \"Internal server error\" });\n    }\n  }  \n\n  static async verifyEmailOtp(req, res) {\n    const { email, otp } = req.body;\n  \n    if (!email || !otp) {\n      return res.status(400).json({ success: false, statusCode: 400, message: \"Email and OTP are required\" });\n    }\n  \n    try {\n      const storedOtpResponse = OtpService.getOtp(email);\n  \n      if (!storedOtpResponse.success) {\n        return res.status(storedOtpResponse.statusCode).json({ success: false, statusCode: storedOtpResponse.statusCode, message: storedOtpResponse.message });\n      }\n  \n      const { storedOtp, otpExpiry } = storedOtpResponse.data;\n  \n      if (Date.now() > otpExpiry) {\n        return res.status(400).json({ success: false, statusCode: 400, message: \"OTP has expired\" });\n      }\n  \n      if (otp !== storedOtp) {\n        return res.status(400).json({ success: false, statusCode: 400, message: \"Invalid OTP\" });\n      }\n  \n      const deleteOtpResponse = OtpService.deleteOtp(email);\n  \n      if (!deleteOtpResponse.success) {\n        return res.status(deleteOtpResponse.statusCode).json({ success: false, statusCode: deleteOtpResponse.statusCode, message: deleteOtpResponse.message });\n      }\n  \n      return res.status(200).json({ success: true, statusCode: 200, message: \"Email verified successfully\" });\n    } catch (error) {\n      console.error(\"Error verifying OTP:\", error);\n      return res.status(500).json({ success: false, statusCode: 500, message: \"Internal server error\" });\n    }\n  }  \n}\n\nexport default EmailController;\n",
    "controllers/UserController.js": "import UserService from \"../services/UserService.js\";\n\nclass UserController {\n  static async updateUser(req, res) {\n    try {\n      const response = await UserService.updateUserService(req.user.id, req.body);\n  \n      if (response.success) {\n        return res.status(response.statusCode).json({ success: true, statusCode: response.statusCode, message: response.message, data: response.data });\n      } else {\n        return res.status(response.statusCode).json({ success: false, statusCode: response.statusCode, message: response.message });\n      }\n    } catch (err) {\n      res.status(500).json({ success: false, statusCode: 500, message: \"Internal server error\" });\n    }\n  }\n  \n  static async deleteUser(req, res) {\n    try {\n      const response = await UserService.deleteUserService(req.user.email);\n  \n      if (response.success) {\n        res.clearCookie(\"token\");\n        return res.status(response.statusCode).json({ success: true, statusCode: response.statusCode, message: response.message });\n      } else {\n        return res.status(response.statusCode).json({ success: false, statusCode: response.statusCode, message: response.message });\n      }\n    } catch (err) {\n      res.status(500).json({ success: false, statusCode: 500, message: \"Internal server error\" });\n    }\n  }  \n\n  static async getUserDetails(req, res) {\n    try {\n      const response = await UserService.getUserDataByEmail(req.email);\n  \n      if (response.success) {\n        return res.status(response.statusCode).json({ success: true, statusCode: response.statusCode, message: response.message, data: response.data });\n      } else {\n        return res.status(response.statusCode).json({ success: false, statusCode: response.statusCode, message: response.message });\n      }\n    } catch (error) {\n      return res.status(500).json({ success: false, statusCode: 500, message: \"Error fetching user details\" });\n    }\n  }\n  \n}\n\nexport default UserController;\n",
    "controllers/AuthController.js": "import AuthService from \"../services/AuthService.js\"\nimport EmailService from \"../services/EmailService.js\";\nimport UserSession from \"../models/UserSession.js\";\n\nclass authController {\n  static async register(req, res) {\n    try {\n      const response = await AuthService.registerUserService(req.body);\n  \n      if (response.success) {\n        if (response.headers) { Object.entries(response.headers).forEach(([key, value]) => { res.setHeader(key, value); }); }\n        return res.status(response.statusCode).json({ success: true, message: response.message, data: response.data });\n      } else {\n        if (response.headers) { Object.entries(response.headers).forEach(([key, value]) => { res.setHeader(key, value); }); }\n        return res.status(response.statusCode).json({ success: false, message: response.message });\n      }\n    } catch (err) {\n      return res.status(500).json({ success: false, message: err.message || \"An error occurred while registering the user\" });\n    }\n  }\n\n  static async createUserWithRole(req, res){\n    const role = req.body.role;\n    try { \n      const validRoles = ['sub-admin', 'owner', 'teacher'];\n      if (!validRoles.includes(role)) {\n        return res.status(400).json({ success: false, message: 'Invalid role' });\n      }\n      const response = await AuthService.registerUserWithRole(req.body);\n  \n      if (response.success) {\n        return res.status(response.statusCode).json({ success: true, message: response.message, data: response.data });\n      } else {\n        return res.status(response.statusCode).json({ success: false, message: response.message });\n      }\n    } catch (err) {\n      return res.status(500).json({ success: false, message: err.message || \"An error occurred while registering the user\" });\n    }\n  }\n  \n  static async sendLoginOtp(req, res) {\n    const { phoneNumber } = req.body;\n    try {\n      const result = await AuthService.generateEmailOtpService(phoneNumber);\n      return res.status(result.statusCode).json({ success: result.success, message: result.message, email: result.email });\n    } catch (error) {\n      console.error('Error sending OTP:', error);\n      return res.status(500).json({ success: false, message: 'Something went wrong while sending OTP' });\n    }\n  }\n  \n  static async loginWithEmailOtp(req, res) {\n    const { email, otp, deviceType } = req.body;\n    try {\n      const result = await AuthService.loginWitEmailService(email, deviceType, otp);\n      // if(result.success)res.cookie(\"token\", result.authToken, { httpOnly: true });\n      return res.status(result.statusCode).json({ success: result.success, message: result.message, authToken: result.authToken });\n    } catch (error) {\n      console.error('Error during login with OTP:', error);\n      return res.status(500).json({ success: false, message: 'Something went wrong while logging in' });\n    }\n  }\n  \n  static async logout(req, res) {\n    const { email, deviceType } = req;\n    try {\n      await UserSession.deleteSession(email, deviceType);\n      res.status(200).json({ success: true, message: \"Logged out successfully\" });\n    } catch (error) {\n      res.status(500).json({ success: false, error: \"Logout failed\" });\n    }\n  }  \n}\n\nexport default authController;\n",
    "controllers/ClassController.js": "import ClassService from '../services/classService.js';\n\nclass ClassController {\n    static async createClass(req, res) {\n        try {\n            const { course_id, class_title, class_date_time, recording_url } = req.body;\n            const teacher_id = req.user.user_id;\n\n            const newClass = await ClassService.createClass(teacher_id, course_id, class_title, class_date_time, recording_url);\n            res.status(201).json(newClass);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to create class' });\n        }\n    }\n\n    static async getClass(req, res) {\n        try {\n            const cls = await ClassService.getClass(req.params.class_id);\n            if (!cls) {\n                return res.status(404).json({ error: 'Class not found' });\n            }\n            res.json(cls);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get class' });\n        }\n    }\n\n    static async getClassesByCourseId(req, res) {\n        try {\n            const classes = await ClassService.getClassesByCourseId(req.params.course_id);\n            res.json(classes);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get classes' });\n        }\n    }\n\n    static async updateClass(req, res) {\n        try {\n            const updatedClass = await ClassService.updateClass(req.params.class_id, req.body);\n            res.json(updatedClass);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to update class' });\n        }\n    }\n\n    static async deleteClass(req, res) {\n        try {\n            await ClassService.deleteClass(req.params.class_id);\n            res.status(204).end();\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to delete class' });\n        }\n    }\n}\n\nexport default ClassController;",
    "controllers/BatchController.js": "import BatchService from '../services/BatchService.js';\n\nclass BatchController {\n    static async createBatch(req, res) {\n        try {\n            const { batch_name, description } = req.body;\n            const teacher_email = req.email;\n\n            const newBatch = await BatchService.createBatch(teacher_email, batch_name, description);\n            res.status(201).json(newBatch);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to create batch' });\n        }\n    }\n\n    static async getBatch(req, res) {\n        try {\n            const batch = await BatchService.getBatch(req.params.batch_id);\n            if (!batch) {\n                return res.status(404).json({ error: 'Batch not found' });\n            }\n            res.json(batch);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get batch' });\n        }\n    }\n\n    static async getAllBatches(req, res) {\n        try {\n            const batches = await BatchService.getAllBatches();\n            res.json(batches);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to get all batches' });\n        }\n    }\n\n    static async updateBatch(req, res) {\n        try {\n            const updatedBatch = await BatchService.updateBatch(req.params.batch_id, req.body);\n            res.json(updatedBatch);\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to update batch' });\n        }\n    }\n\n    static async deleteBatch(req, res) {\n        try {\n            await BatchService.deleteBatch(req.params.batch_id);\n            res.status(204).end();\n        } catch (error) {\n            console.error(error);\n            res.status(500).json({ error: 'Failed to delete batch' });\n        }\n    }\n}\n\nexport default BatchController;\n",
    "models/CourseModel.js": "import { DynamoDBClient, PutItemCommand, GetItemCommand, UpdateItemCommand, DeleteItemCommand, QueryCommand } from \"@aws-sdk/client-dynamodb\";\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\n\nconst dynamoDbClient = new DynamoDBClient({ region: process.env.AWS_REGION });\nconst TableName = process.env.DYNAMODB_COURSE_TABLE; \n\nclass CourseData {\n    static async createCourse(course) {\n        const params = {\n            TableName,\n            Item: marshall(course),\n        };\n\n        try {\n            const command = new PutItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return course;\n        } catch (error) {\n            console.error(\"Error creating course:\", error);\n            throw error;\n        }\n    }\n\n    static async getCourseById(course_id) {\n        const params = {\n            TableName,\n            Key: marshall({ course_id }),\n        };\n\n        try {\n            const command = new GetItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data.Item ? unmarshall(data.Item) : null;\n        } catch (error) {\n            console.error(\"Error getting course:\", error);\n            throw error;\n        }\n    }\n\n    static async getCoursesByBatchId(batch_id) { // New function to get courses within a batch\n        const params = {\n            TableName,\n            IndexName: 'batch_id-index',  // Assuming you have a GSI on batch_id\n            KeyConditionExpression: \"batch_id = :batch_id\",\n            ExpressionAttributeValues: marshall({ \":batch_id\": batch_id }),\n        };\n\n        try {\n            const command = new QueryCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data.Items.map(item => unmarshall(item));\n        } catch (error) {\n            console.error(\"Error getting courses by batch ID:\", error);\n            throw error;\n        }\n    }\n\n\n    static async updateCourse(course_id, updatedCourseData) {\n        const existingCourse = await this.getCourseById(course_id);\n        if (!existingCourse) {\n            throw new Error('Course not found');\n        }\n\n        const updateParams = {\n            TableName,\n            Key: marshall({ course_id }),\n            UpdateExpression: \"SET \",\n            ExpressionAttributeValues: marshall({}),\n            ReturnValues: \"ALL_NEW\"\n        };\n\n        for (const key in updatedCourseData) {\n            if (updatedCourseData.hasOwnProperty(key)) {\n                updateParams.UpdateExpression += `${key} = :${key}, `;\n                updateParams.ExpressionAttributeValues[`:${key}`] = updatedCourseData[key];\n            }\n        }\n\n        updateParams.UpdateExpression = updateParams.UpdateExpression.slice(0, -2);\n\n        try {\n            const command = new UpdateItemCommand(updateParams);\n            const data = await dynamoDbClient.send(command);\n            return unmarshall(data.Attributes);\n        } catch (error) {\n            console.error(\"Error updating course:\", error);\n            throw error;\n        }\n    }\n\n    static async deleteCourse(course_id) {\n        const params = {\n            TableName,\n            Key: marshall({ course_id }),\n        };\n\n        try {\n            const command = new DeleteItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data;\n        } catch (error) {\n            console.error(\"Error deleting course:\", error);\n            throw error;\n        }\n    }\n}\n\nexport default CourseData;",
    "models/UserModel.js": "import ddbClient from \"../config/dynamoDB.js\";\nimport {\n  PutItemCommand,\n  GetItemCommand,\n  UpdateItemCommand,\n  DeleteItemCommand,\n  QueryCommand,\n} from \"@aws-sdk/client-dynamodb\";\nimport dotenv from \"dotenv\";\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\n\ndotenv.config();\n\nclass UserModel {\n  static async createUser(user) {\n    const authParams = {\n      TableName: process.env.AUTH_TABLE,\n      Item: marshall({\n        name: user.name,\n        email: user.email,\n        phoneNumber: user.phoneNumber,\n        role: user.role,\n        exam_registered_for:user.exam_registered_for || null\n      }),\n    };\n\n    try {\n      const authCommand = new PutItemCommand(authParams);\n      await ddbClient.send(authCommand);\n      return { success: true, message: \"User created successfully\" };\n    } catch (err) {\n      console.error(\"Error creating user in DynamoDB:\", err);\n      return { success: false, message: \"Error creating user\" };\n    }\n  }\n\n  static async getUserByEmail(email) {\n    const authParams = {\n      TableName: process.env.AUTH_TABLE,\n      Key: marshall({ email }),\n    };\n\n    try {\n      const authCommand = new GetItemCommand(authParams);\n      const { Item: authItem } = await ddbClient.send(authCommand);\n      if (!authItem) {\n        return { success: false, message: \"User not found\" };\n      }\n\n      const user = unmarshall(authItem);\n\n      return {\n        success: true,\n        data: user,\n      };\n    } catch (err) {\n      console.error(\"Error fetching user from DynamoDB:\", err);\n      return { success: false, error: \"Error fetching user\" };\n    }\n  }\n\n  static async getUserPhoneNumber(phoneNumber){\n    const params = {\n      TableName: process.env.AUTH_TABLE,\n      IndexName: 'phoneNumber-index',\n      KeyConditionExpression: 'phoneNumber = :phoneNumber',\n      ExpressionAttributeValues: {\n        ':phoneNumber': { S: phoneNumber }\n      }\n    };\n\n    try {\n      const authCommand = new QueryCommand(params);\n      const { Items: queryItems } = await ddbClient.send(authCommand);\n      if (!queryItems[0]) {\n        return { success: false, message: \"User not found\" };\n      }\n      const user = unmarshall(queryItems[0]);\n\n      return { success: true, ...user };\n    } catch (err) {\n      console.error(\"Error fetching user from DynamoDB:\", err);\n      return { success: false, error: \"Error fetching user\" };\n    }\n  }\n\n  static async updateUser(userId, updatedFields) {\n    const updateExpressions = [];\n    const attributeValues = {};\n\n    for (const [key, value] of Object.entries(updatedFields)) {\n      updateExpressions.push(`${key} = :${key}`);\n      attributeValues[`:${key}`] = { S: value };\n    }\n\n    const params = {\n      TableName: process.env.USERS_TABLE,\n      Key: {\n        userId: { S: userId },\n      },\n      UpdateExpression: `SET ${updateExpressions.join(\", \")}`,\n      ExpressionAttributeValues: attributeValues,\n      ReturnValues: \"ALL_NEW\",\n    };\n\n    try {\n      const command = new UpdateItemCommand(params);\n      const { Attributes } = await ddbClient.send(command);\n      return { success: true, data: Attributes };\n    } catch (err) {\n      console.error(\"Error updating user in DynamoDB:\", err);\n      return { success: false, message: \"Error updating user\" };\n    }\n  }\n\n  static async deleteUser(email) {\n    const authParams = {\n      TableName: process.env.AUTH_TABLE,\n      Key: marshall({ email }),\n    };\n\n    const userDataParams = {\n      TableName: process.env.USER_DATA_TABLE,\n      Key: marshall({ email }),\n    };\n\n    const userDocsParams = {\n      TableName: process.env.USER_DOCS_TABLE,\n      Key: marshall({ email }),\n    };\n\n    try {\n      const authCommand = new DeleteItemCommand(authParams);\n      const userDataCommand = new DeleteItemCommand(userDataParams);\n      const userDocsCommand = new DeleteItemCommand(userDocsParams);\n      await ddbClient.send(authCommand);\n      await ddbClient.send(userDataCommand);\n      await ddbClient.send(userDocsCommand);\n      return { success: true, message: \"User deleted successfully\" };\n    } catch (err) {\n      console.error(\"Error deleting user from DynamoDB:\", err);\n      return { success: false, message: \"Error deleting user\" };\n    }\n  }\n\n  static async updatePassword(email, newPassword) {\n    const params = {\n      TableName: process.env.AUTH_TABLE,\n      Key: marshall({ email }),\n      UpdateExpression: \"SET password = :password\",\n      ExpressionAttributeValues: marshall({\n        \":password\": newPassword,\n      }),\n      ReturnValues: \"ALL_NEW\",\n    };\n\n    try {\n      const command = new UpdateItemCommand(params);\n      const { Attributes } = await ddbClient.send(command);\n      return { success: true, data: Attributes };\n    } catch (err) {\n      console.error(\"Error updating password in DynamoDB:\", err);\n      return { success: false, message: \"Error updating password\" };\n    }\n  }\n\n  static async getDataFromTable(tableName, key) {\n    const params = {\n      TableName: tableName,\n      Key: marshall(key),\n    };\n\n    try {\n      const command = new GetItemCommand(params);\n      const result = await ddbClient.send(command);\n\n      if (!result.Item) {\n        throw new Error(`No data found for key: ${JSON.stringify(key)}`);\n      }\n\n      const item = unmarshall(result.Item);\n      return item;\n    } catch (error) {\n      console.error(`Error fetching data from ${tableName}:`, error);\n      throw error;\n    }\n  }\n\n  static async getUserDataByEmail(email) {\n    try {\n      const authData = await this.getDataFromTable(process.env.AUTH_TABLE, {\n        email,\n      });\n      const userData = await this.getDataFromTable(\n        process.env.USER_DATA_TABLE,\n        { email }\n      );\n      const userDocs = await this.getDataFromTable(\n        process.env.USER_DOCS_TABLE,\n        { email }\n      );\n      return { authData, userData, userDocs };\n    } catch (error) {\n      console.error(\"Error fetching user details:\", error);\n      throw new Error(\"Error fetching user details\");\n    }\n  }\n}\n\nexport default UserModel;\n",
    "models/BatchModel.js": "import ddbClient from \"../config/dynamoDB.js\";\nimport {\n  PutItemCommand,\n  GetItemCommand,\n  UpdateItemCommand,\n  DeleteItemCommand,\n  QueryCommand,\n} from \"@aws-sdk/client-dynamodb\";\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\n\nclass BatchModel {\n  static async createBatch(batch) {\n    const params = {\n      TableName: process.env.BATCH_TABLE,\n      Item: marshall(batch),\n    };\n\n    try {\n      const command = new PutItemCommand(params);\n      const data = await ddbClient.send(command);\n      return batch;\n    } catch (error) {\n      console.error(\"Error creating batch:\", error);\n      throw error;\n    }\n  }\n\n  static async getBatchById(batch_id) {\n    const params = {\n      TableName: process.env.BATCH_TABLE,\n      Key: marshall({ batch_id }),\n    };\n\n    try {\n      const command = new GetItemCommand(params);\n      const data = await ddbClient.send(command);\n      return data.Item ? unmarshall(data.Item) : null;\n    } catch (error) {\n      console.error(\"Error getting batch:\", error);\n      throw error;\n    }\n  }\n\n  static async getAllBatches() {\n    const params = {\n      TableName: process.env.BATCH_TABLE,\n    };\n    try {\n      const command = new ScanCommand(params);\n      const data = await ddbClient.send(command);\n      return data.Items.map((item) => unmarshall(item));\n    } catch (error) {\n      console.error(\"Error getting all batches:\", error);\n      throw error;\n    }\n  }\n\n  static async updateBatch(batch_id, updatedBatchData) {\n    const existingBatch = await getBatchById(batch_id);\n    if (!existingBatch) {\n      throw new Error(\"Batch not found\");\n    }\n\n    const updateParams = {\n      TableName: process.env.BATCH_TABLE,\n      Key: marshall({ batch_id }),\n      UpdateExpression: \"SET \",\n      ExpressionAttributeValues: marshall({}),\n      ReturnValues: \"ALL_NEW\",\n    };\n\n    for (const key in updatedBatchData) {\n      if (updatedBatchData.hasOwnProperty(key)) {\n        updateParams.UpdateExpression += `${key} = :${key}, `;\n        updateParams.ExpressionAttributeValues[`:${key}`] =\n          updatedBatchData[key];\n      }\n    }\n\n    updateParams.UpdateExpression = updateParams.UpdateExpression.slice(0, -2);\n\n    try {\n      const command = new UpdateItemCommand(updateParams);\n      const data = await ddbClient.send(command);\n      return unmarshall(data.Attributes);\n    } catch (error) {\n      console.error(\"Error updating batch:\", error);\n      throw error;\n    }\n  }\n\n  static async deleteBatch(batch_id) {\n    const params = {\n      TableName: process.env.BATCH_TABLE,\n      Key: marshall({ batch_id }),\n    };\n\n    try {\n      const command = new DeleteItemCommand(params);\n      const data = await ddbClient.send(command);\n      return data;\n    } catch (error) {\n      console.error(\"Error deleting batch:\", error);\n      throw error;\n    }\n  }\n}\n\nexport default BatchModel;\n",
    "models/ClassModel.js": "import { DynamoDBClient, PutItemCommand, GetItemCommand, UpdateItemCommand, DeleteItemCommand, QueryCommand } from \"@aws-sdk/client-dynamodb\";\nimport { marshall, unmarshall } from \"@aws-sdk/util-dynamodb\";\n\nconst dynamoDbClient = new DynamoDBClient({ region: process.env.AWS_REGION });\nconst TableName = process.env.DYNAMODB_CLASS_TABLE;\n\nclass ClassData {\n    static async createClass(cls) { // Renamed from just \"class\" to \"cls\" to avoid keyword conflict\n        const params = {\n            TableName,\n            Item: marshall(cls),\n        };\n\n        try {\n            const command = new PutItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return cls;\n        } catch (error) {\n            console.error(\"Error creating class:\", error);\n            throw error;\n        }\n    }\n\n    static async getClassById(class_id) {\n        const params = {\n            TableName,\n            Key: marshall({ class_id }),\n        };\n\n        try {\n            const command = new GetItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data.Item ? unmarshall(data.Item) : null;\n        } catch (error) {\n            console.error(\"Error getting class:\", error);\n            throw error;\n        }\n    }\n\n    static async getClassesByCourseId(course_id) {\n        const params = {\n            TableName,\n            IndexName: 'course_id-index', // Assuming you have a GSI on course_id\n            KeyConditionExpression: \"course_id = :course_id\",\n            ExpressionAttributeValues: marshall({ \":course_id\": course_id }),\n        };\n\n        try {\n            const command = new QueryCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data.Items.map(item => unmarshall(item));\n        } catch (error) {\n            console.error(\"Error getting classes by course ID:\", error);\n            throw error;\n        }\n    }\n\n    static async updateClass(class_id, updatedClassData) {\n        const existingClass = await this.getClassById(class_id);\n        if (!existingClass) {\n            throw new Error('Class not found');\n        }\n\n        const updateParams = {\n            TableName,\n            Key: marshall({ class_id }),\n            UpdateExpression: \"SET \",\n            ExpressionAttributeValues: marshall({}),\n            ReturnValues: \"ALL_NEW\"\n        };\n\n        for (const key in updatedClassData) {\n            if (updatedClassData.hasOwnProperty(key)) {\n                updateParams.UpdateExpression += `${key} = :${key}, `;\n                updateParams.ExpressionAttributeValues[`:${key}`] = updatedClassData[key];\n            }\n        }\n\n        updateParams.UpdateExpression = updateParams.UpdateExpression.slice(0, -2);\n\n        try {\n            const command = new UpdateItemCommand(updateParams);\n            const data = await dynamoDbClient.send(command);\n            return unmarshall(data.Attributes);\n        } catch (error) {\n            console.error(\"Error updating class:\", error);\n            throw error;\n        }\n    }\n\n    static async deleteClass(class_id) {\n        const params = {\n            TableName,\n            Key: marshall({ class_id }),\n        };\n\n        try {\n            const command = new DeleteItemCommand(params);\n            const data = await dynamoDbClient.send(command);\n            return data;\n        } catch (error) {\n            console.error(\"Error deleting class:\", error);\n            throw error;\n        }\n    }\n}\n\nexport default classData;",
    "models/UserSession.js": "import { DynamoDBClient, PutItemCommand, GetItemCommand, DeleteItemCommand } from '@aws-sdk/client-dynamodb';\nimport  { marshall, unmarshall } from '@aws-sdk/util-dynamodb';\n\nconst client = new DynamoDBClient({ region: process.env.AWS_REGION });\n\nclass UserSession {\n  static async createOrUpdateSession(email, deviceType, token) {\n    const params = {\n      TableName: process.env.SESSIONS_TABLE,\n      Item: marshall({\n        email,\n        deviceType,\n        token,\n        createdAt: Date.now(),\n      }),\n    };\n    await client.send(new PutItemCommand(params));\n  }\n\n  static async getSessionByUserAndDevice(email, deviceType) {\n    const params = {\n      TableName: process.env.SESSIONS_TABLE,\n      Key: marshall({\n        email,\n        deviceType,\n      }),\n    };\n    const result = await client.send(new GetItemCommand(params));\n    return result.Item ? unmarshall(result.Item) : null;\n  }\n\n  static async deleteSession(email, deviceType) {\n    const params = {\n      TableName: process.env.SESSIONS_TABLE,\n      Key: marshall({\n        email,\n        deviceType,\n      }),\n    };\n    await client.send(new DeleteItemCommand(params));\n  }\n}\n\nexport default  UserSession;",
    "middleware/ErrorMiddleware.js": "const errorHandler = (err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({ success: false, message: 'Internal Server Error' });\n};\n\nmodule.exports = { errorHandler };",
    "middleware/AuthMiddleware.js": "import jwt from \"jsonwebtoken\";\nimport UserSession from \"../models/UserSession.js\";\n\nclass AuthMiddleware {\n  static async auth(req, res, next) {\n    try {\n      var token = req.header(\"Authorization\")?.replace(\"Bearer \", \"\");\n      if (!token)token = req.cookie?.token;\n      if(!token)return res.status(401).json({success: false, message:\"Unauthorised\"})\n      const decoded = jwt.verify(token, process.env.JWT_SECRET);\n      const session = await UserSession.getSessionByUserAndDevice(\n        decoded.email,\n        decoded.deviceType\n      );\n\n      if (!session || session.token !== token) {\n        return res.status(401).json({success: false, message: \"Unauthorised\"})\n      }\n\n      req.email = decoded.email;\n      req.deviceType = decoded.deviceType;\n      next();\n    } catch (error) {\n      console.error(error)\n      next()\n    }\n  }\n}\n\nexport default AuthMiddleware;\n",
    "middleware/RoleMiddleware.js": "import UserModel from \"../models/UserModel.js\";\n\nconst roleHierarchy = {\n    \"owner\": 4,\n    \"admin\": 3,\n    \"sub-admin\": 2,\n    \"teacher\": 1,\n    \"user\": 0,\n  };\n  \n  class RoleMiddleware {\n    static async checkRole(roles) {\n      return async (req, res, next) => {\n        try {\n          const user = await UserModel.getUserByEmail(req.email);\n  \n          if (!user.success) {\n            return res.status(404).json({ success: false, message: \"User not found\" });\n          }\n  \n          if (!roles.includes(user.data.role)) {\n            return res.status(403).json({ success: false, message: \"Access denied. You don't have permission to access this resource\" });\n          }\n  \n          next();\n        } catch (error) {\n          console.error(\"Error checking role:\", error);\n          return res.status(500).json({ success: false, message: \"Internal server error\" });\n        }\n      };\n    }\n  \n    static async checkRoleHierarchy(req, res, next) {\n      try {\n        const creator = await UserModel.getUserByEmail(req.email);\n  \n        if (!creator.success) {\n          return res.status(404).json({ success: false, message: \"Creator not found\" });\n        }\n  \n        const { role: creatorRole } = creator.data;\n  \n        const { role: newUserRole } = req.body;\n  \n        if (roleHierarchy[creatorRole] <= roleHierarchy[newUserRole]) {\n          return res.status(403).json({\n            success: false,\n            message: `You do not have permission to create a user with the ${newUserRole} role`,\n          });\n        }\n  \n        next();\n      } catch (error) {\n        console.error(\"Error checking role hierarchy:\", error);\n        return res.status(500).json({ success: false, message: \"Internal server error\" });\n      }\n    }\n  }\n  \n  export default RoleMiddleware;\n  ",
    "routes/BatchRoutes.js": "import express from 'express';\nconst router = express.Router();\nimport AuthMiddleware from \"../middleware/AuthMiddleware.js\"\nimport BatchController from \"../controllers/BatchController.js\"\nimport RoleMiddleware from '../middleware/RoleMiddleware.js';\n\n\nrouter.post('/', AuthMiddleware.auth,await RoleMiddleware.checkRole([\"teacher\"]), BatchController.createBatch);\nrouter.get('/:batch_id', BatchController.getBatch);\nrouter.get('/', BatchController.getAllBatches);\nrouter.put('/:batch_id', AuthMiddleware.auth,await RoleMiddleware.checkRole([\"teacher\"]), BatchController.updateBatch);\nrouter.delete('/:batch_id', AuthMiddleware.auth,await RoleMiddleware.checkRole([\"teacher\"]), BatchController.deleteBatch);\n\nexport default router;",
    "routes/AuthRoutes.js": "import express from \"express\";\nimport multer from \"multer\";\nimport AuthController from \"../controllers/AuthController.js\";\nimport AuthMiddleware from \"../middleware/AuthMiddleware.js\";\nimport RoleMiddleware from \"../middleware/RoleMiddleware.js\";\n\nconst upload = multer();\nconst router = express.Router();\n\nrouter.post(\"/register\", AuthController.register);\n\nrouter.post(\"/create-user\",\n  AuthMiddleware.auth,\n  await RoleMiddleware.checkRole([\"admin\", \"sub-admin\", \"owner\"]),\n  RoleMiddleware.checkRoleHierarchy,\n  AuthController.createUserWithRole);\nrouter.post(\"/login\", AuthController.loginWithEmailOtp);\nrouter.post(\"/send-login-otp\", AuthController.sendLoginOtp);\nrouter.post(\"/logout\", AuthController.logout);\n\nexport default router\n",
    "routes/OtpRoutes.js": "import express from 'express';\nconst router = express.Router();\nimport EmailController from '../controllers/EmailController.js';\n\nrouter.post('/send', EmailController.sendEmailOtp);\n\nrouter.post('/verify', EmailController.verifyEmailOtp);\n\nexport default router;\n",
    "routes/CourseRoutes.js": "import express from 'express';\nconst router = express.Router();\nimport CourseController from '../controllers/courseController.js';\nimport authMiddleware from '../middleware/authMiddleware.js';\n\nrouter.post('/', authMiddleware.isAuthenticated, authMiddleware.isTeacher, CourseController.createCourse);\nrouter.get('/:course_id', CourseController.getCourse);\nrouter.get('/batch/:batch_id', CourseController.getCoursesByBatchId);\nrouter.put('/:course_id', authMiddleware.isAuthenticated, authMiddleware.isTeacher, CourseController.updateCourse);\nrouter.delete('/:course_id', authMiddleware.isAuthenticated, authMiddleware.isTeacher, CourseController.deleteCourse);\n\nexport default router;",
    "routes/UserRoutes.js": "import express from 'express';\nimport authMiddleware from '../middleware/AuthMiddleware.js';\nimport UserController from '../controllers/UserController.js';\n\nconst router = express.Router();\n\nrouter.put('/update', authMiddleware.auth, UserController.updateUser);\nrouter.delete('/delete', authMiddleware.auth, UserController.deleteUser);\nrouter.get('/:email', UserController.getUserDetails);\n\nexport default router;",
    "routes/ClassRoutes.js": "import express from 'express';\nconst router = express.Router();\nimport ClassController from '../controllers/ClassController.js';\nimport AuthMiddleware from '../middleware/AuthMiddleware.js';\n\nrouter.post('/',  AuthMiddleware.auth, AuthMiddleware.checkRole([\"teacher\"]), ClassController.createClass);\nrouter.get('/:class_id', ClassController.getClass);\nrouter.get('/course/:course_id', ClassController.getClassesByCourseId);\nrouter.put('/:class_id',  AuthMiddleware.auth, AuthMiddleware.checkRole([\"teacher\"]), ClassController.updateClass);\nrouter.delete('/:class_id',  AuthMiddleware.auth, AuthMiddleware.checkRole([\"teacher\"]), ClassController.deleteClass);\n\nexport default router;"
}